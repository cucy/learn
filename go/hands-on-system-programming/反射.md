Section 5: A Guide to Using Reflection and CGO
This section focuses on two tools that are very controversial—reflection, which allows the creation of generic code but has a great cost in terms of performance, and CGO, which allows the use of C code in a Go application but makes it more complex to debug and control the application.

This section consists of the following chapters:

Chapter 15, Using Reflection
Chapter 16, Using CGO

第5节：反射和CGO使用指南
本节重点介绍两个非常有争议的反射工具，这两个工具允许创建通用代码，但在性能方面成本很高；和允许在Go应用程序中使用C代码，但使调试和控制应用程序更加复杂的CGO。
本节包括以下章节：
第十五章运用反思
第16章，使用CGO



# Using Reflection
This chapter is about reflection, a tool that allows an application to inspect its own code, overcoming some of the limitations imposed by Go static typing and its lack of generics. This can be very helpful, for instance, for producing packages that are capable of handling any type of input that they receive.

The following topics will be covered in this chapter:

Understanding interfaces and type assertions
Learning about interaction with basic types
Using reflection with complex types
Evaluating the cost of reflection
Learning the best practices of reflection usage


使用反射
本章是关于反射的，一种允许应用程序检查自己的代码的工具，它克服了Go静态类型所带来的一些限制，并且缺少泛型。例如，对于生成能够处理他们接收到的任何类型输入的包来说，这非常有用。
本章将讨论以下主题：
了解接口和类型断言
学习与基本类型的交互
使用复杂类型的反射
评估反射成本
学习反射使用的最佳实践



# What's reflection?
Reflection is a very powerful feature that allows meta-programming, the capability of an application to examine its own structure. It's very useful to analyze the types in an application at runtime, and it is used in many encoding packages such as JSON and XML.

什么是反射？
反射是一个非常强大的特性，它允许元编程，即应用程序检查自身结构的能力。在运行时分析应用程序中的类型非常有用，它被用于许多编码包，如JSON和XML。


# Type assertions
We briefly mentioned how type assertions work in Chapter 3, An Overview of Go. A type assertion is an operation that allows us to go from interface to concrete type and vice versa. It takes the following form:

类型断言
我们在第3章（Go概述）中简要地提到了类型断言是如何工作的。类型断言是一种操作，它允许我们从接口转到具体类型，反之亦然。其形式如下：

```
# unsafe assertion
v := SomeVar.(SomeType)

# safe assertion
v, ok := SomeVar.(SomeType)
```

The first version is unsafe, and it assigns a value to a single variable.

Using assertion as an argument of a function also counts as unsafe. This type of operation panics if the assertion is wrong:

```
第一个版本是不安全的，它为单个变量赋值。
将断言用作函数的参数也会被视为不安全的。如果断言错误，此类型的操作将恐慌：

func main() {
    var a interface{} = "hello"
    fmt.Println(a.(string)) // ok
    fmt.Println(a.(int))    // panics!
}
```

The second version uses a Boolean a as second value, and it will show the success of the operation. If the assertion is not possible, the first value will always be a zero value for the asserted type:

第二个版本使用布尔值A作为第二个值，它将显示操作的成功。如果断言不可能，则第一个值将始终是断言类型的零值：

```
func main() {
    var a interface{} = "hello"
    s, ok := a.(string) // true
    fmt.Println(s, ok)
    i, ok := a.(int) // false
    fmt.Println(i, ok)
}
```

# Interface assertion

Assertion can also be done from one interface to another. Imagine having two different interfaces:

```
断言也可以从一个接口到另一个接口。想象一下有两个不同的接口：

type Fooer interface {
    Foo()
}

type Barer interface {
    Bar()
}
```

Let's define a type that implements one of them and another that implements both:

``` 
让我们定义一个实现其中一个和另一个实现这两个的类型：

type A int

func (A) Foo() {}

type B int

func (B) Bar() {}
func (B) Foo() {}

```

If we define a new variable for the first interface, the assertion to the second is going to be successful only if the underlying value has a type that implements both; otherwise, it's going to fail:

```
如果我们为第一个接口定义了一个新变量，那么只有当基础值的类型实现了这两个接口时，对第二个接口的断言才会成功；否则，它将失败：


func main() {
	var a Fooer 
	
	a = A(0)
	v, ok := a.(Barer)
	fmt.Println(v, ok) // <nil> false

	a = B(0)	
	v, ok = a.(Barer)
	fmt.Println(v, ok) // 0 true
}

```

A use case scenario could be having the io.Reader interface, checking out whether it is also an io.Closer interface, and wrapping it in the ioutil.NopCloser function (which returns an io.ReadCloser interface) if not:

```
用例场景可能具有IO.Reader接口，检查它是否也是IO.Closer接口，并将其包装在ioutil.noCloser函数中（该函数返回IO.ReadCloser接口），如果不是：

func Closer(r io.Reader) io.ReadCloser {
	if rc, ok := r.(io.ReadCloser); ok {
		return rc
	}
	return ioutil.NopCloser(r)
}

func main() {
	log.Printf("%T", Closer(&bytes.Buffer{}))  // ioutil.nopCloser
	log.Printf("%T", Closer(&os.File{}))  // ioutil.nopCloser
}
```

There is an important aspect to interfaces that we need to underline before jumping onto reflection—its representation is always a tuple interface-value where the value is a concrete type and cannot be another interface.
接口有一个重要的方面，我们需要在跳到反射之前加下划线。它的表示形式总是一个元组接口值，其中的值是一个具体的类型，不能是另一个接口。


# Understanding basic mechanics
The reflection package allows you to extract the type and value from any interface{} variable. This can be done using the following:

Using reflection.TypeOf returns the type of the interface in a reflection.Type  variable.
The reflection.ValueOf function returns the value of the interface using the reflection.Value variable.

```
了解基本力学
反射包允许您从任何接口变量中提取类型和值。这可以使用以下方法完成：
使用reflection.type of返回reflection.type变量中接口的类型。
函数的reflection.value of使用reflection.value变量返回接口的值。


```

# Value and Type methods

A reflect.Value type also carries information of the type that can be retrieved with the Type method:

```
reflect.value类型还包含可使用类型方法检索的类型信息：

func main() {
	var a interface{} = int64(23)
	fmt.Println(reflect.TypeOf(a).String()) // int64
	
	fmt.Println(reflect.ValueOf(a).String()) // <int64 Value>
	
	fmt.Println(reflect.ValueOf(a).Type().String()) // int64
}
```

# Kind
Another important property of reflect.Type is Kind, which is an enumeration of basic types and generic complex types. The main relationship between reflect.Kind and reflect.Type is that the first represents the memory representation of the second.

For built-in types, Kind and Type are the same, but for custom types they will differ—the Type value will be what is expected, but the Kind value will be one of the built-in ones on which the custom type is defined:

```
种类
reflect.type的另一个重要属性是kind，它是基本类型和一般复杂类型的枚举。reflect.kind和reflect.type之间的主要关系是，第一个表示第二个的内存表示。
对于内置类型，种类和类型是相同的，但对于自定义类型，它们将不同，类型值将是预期值，但种类值将是定义自定义类型的内置值之一：


func main() {
	var a interface{}

	a = "" // bulltin string  内置类型
	t := reflect.TypeOf(a)
	fmt.Println(t.String(), t.Kind()) // string string

	type A string // custom type 自定义类型
	a = A("")
	t = reflect.TypeOf(a)
	fmt.Println(t.String(), t.Kind()) // main.A string
}

```


For the composite type, it will reflect just the main type and not the underlying ones. This means that a pointer to a structure or to an integer is the same kind, reflect.Pointer:

```  
对于复合类型，它只反映主类型，而不反映底层类型。这意味着指向结构或整数的指针是同一种类型，reflect。指针：

func main() {
	var a interface{}

	a = new(int) // int pointer
	t := reflect.TypeOf(a)
	fmt.Println(t.String(), t.Kind()) // *int ptr

	a = new(struct{}) // struct pointer
	t = reflect.TypeOf(a)
	fmt.Println(t.String(), t.Kind()) // *struct {} ptr

}
```

# Value to interface

In the same way that we can get reflect.Value from any interface{} value,  we can execute the reverse operation and obtain interface{}from reflect.Value. This is done using the Interface method of the reflected value, and be cast to a concrete type if necessary. If the interested method or function accepts an empty interface, such as json.Marshal or fmt.Println, the returned value can be passed directly without any casting:

```
接口值
同样，我们可以从任何接口值中获取reflect.value，我们可以执行反向操作并从reflect.value中获取接口。这是使用反射值的接口方法完成的，并在必要时铸造成混凝土类型。如果感兴趣的方法或函数接受空接口，如json.marshal或fmt.println，则返回的值可以直接传递而不进行任何转换：

func main() {
	var a interface{} = int(12)
	v := reflect.ValueOf(a)
	fmt.Println(v.String()) // <int Value>
	
	fmt.Printf("%v", v.Interface()) // 12
}
```

# Manipulating values
Transforming values in their reflection and going back to the value is not very useful if the values themselves cannot be changed. That's why our next step is seeing how to change them using the reflection package.

```
操纵值
如果无法更改值本身，则在其反射中转换值并返回到该值并不十分有用。这就是为什么我们的下一步是了解如何使用反射包更改它们。


```

# Changing values
There is a series of methods of the reflect.Value type that allow you to change the underlying value:

Set: Uses another reflect.Value
SetBool: Boolean
SetBytes: Byte slice
SetComplex: Any complex type
SetFloat: Any float type
SetInt: Any signed integer type
SetPointer: A pointer
SetString: A string
SetUint: Any unsigned integer
In order to set a value, it needs to editable, and this happens in specific conditions. To verify this, there is a method, CanSet, which returns true if a value can be changed. If the value cannot be changed and a Set method is called anyway, the application will panic:

```
更改值
Reflect.Value类型的一系列方法允许您更改基础值：
集合：使用另一个reflect.value
setbool:布尔值
setbytes:字节片
setcomplex：任何复杂类型
setfloat：任何浮点类型
setint：任何有符号整数类型
setpointer：指针
设置字符串：字符串
setuint：任何无符号整数
为了设置一个值，它需要可编辑，这在特定的条件下发生。为了验证这一点，有一个方法canset，如果可以更改某个值，它将返回true。如果无法更改该值，并且仍然调用set方法，则应用程序将死机：



func main() {
	var a = int64(12)
	v := reflect.ValueOf(a)
	fmt.Println(v.String(), v.CanSet()) // <int64 Value> false
	
	v.SetInt(24) // panic: reflect: reflect.Value.SetInt using unaddressable value
}
```

In order to be changed, a value needs to be addressable. A value is addressable if it's possible to modify the actual storage where the object is saved. When creating a new value using a basic built-in type, such as string , what gets passed to the function is interface{} , which hosts a copy of the string.

Changing this copy would result in a variation of the copy with no effect on the original variable. This would be incredibly confusing, and it would make the usage of a sensible tool such as reflection, even harder. That's why, instead of this useless behavior, the reflect package panics—it's a design choice. This explains why the last example panicked.

We can create reflect.Value using the pointer to the value we want to change, and access the value using the Elem method. This will give us a value that is addressable because we copied the pointer instead of the value, so the reflected value is still a pointer to the variable:

```
要更改，值必须是可寻址的。如果可以修改保存对象的实际存储，则值是可寻址的。使用基本内置类型（如字符串）创建新值时，传递给函数的是接口，它承载字符串的副本。
更改此副本将导致副本的更改，而不会影响原始变量。这将是令人难以置信的混乱，而且它将使明智的工具（如反射）的使用更加困难。这就是为什么，反射包会恐慌，而不是这种无用的行为，它是一种设计选择。这就解释了上一个例子为什么惊慌失措。
我们可以使用指向要更改的值的指针创建reflect.value，并使用elem方法访问该值。这将给我们一个可寻址的值，因为我们复制了指针而不是值，所以反射值仍然是指向变量的指针：


func main() {
	var a = int64(12)
	v := reflect.ValueOf(&a)
	fmt.Println(v.String(), v.CanSet()) // <*int64 Value> false
	
	e := v.Elem()
	fmt.Println(e.String(), e.CanSet()) // <int64 Value> true
	e.SetInt(24)
	fmt.Println(a) // 24 
}
```

# Creating new values
The reflect package allows us also to create new values using types. There are several functions that allow us to create a value:

MakeChan creates a new channel value
MakeFunc creates a new function value
MakeMap and MakeMapWithSize creates a new map value
MakeSlice creates a new slice value
New creates a new pointer to the type
NewAt creates a new pointer to the type using the selected address
Zero creates a zero value of the selected type
The following code shows how to create new values in a couple of different ways:

```
创建新值
反射包还允许我们使用类型创建新值。有几个函数允许我们创建一个值：
makechan创建新的渠道价值
makefunc创建新的函数值
makemap和makemapwithsize创建新的映射值
makeslice创建新的切片值
新建创建指向类型的新指针
newat使用所选地址创建指向类型的新指针
零创建所选类型的零值
下面的代码显示了如何以几种不同的方式创建新值：


func main() {
	t := reflect.TypeOf(int64(100))
	// zero value
	fmt.Printf("%#v\n", reflect.Zero(t)) // 0 
	// pointer to int
	fmt.Printf("%#v\n", reflect.New(t)) // (*int64)(0x414030)
}

```

# Handling complex types
After seeing how to handle the reflection basics, we will now see how complex data types such as structures and maps can also be handled using reflection.

```
处理复杂类型
在了解了如何处理反射基础知识之后，我们现在将了解如何使用反射来处理结构和映射等复杂的数据类型。


```

# Data structures
For changeability, structures work in exactly the same way as the basic types; we need to obtain the reflection of the pointer, then access its element in order to be able to change the value, because using the structure directly would produce a copy of it and it would panic when changing values.

We can replace the value of the entire structure using the Set method, after obtaining the new value's reflection:

```
数据结构
对于可更改性，结构的工作方式与基本类型完全相同；我们需要获取指针的反射，然后访问其元素，以便能够更改值，因为直接使用结构会生成指针的副本，并且在更改值时会恐慌。
在获得新值的反射后，我们可以使用set方法替换整个结构的值：

func main() {
	type X struct {
		A, B int
		c    string
	}
	var a = X{10, 100, "apple"}
	fmt.Println(a) // {10 100 apple}
	
	e := reflect.ValueOf(&a).Elem()
	
	fmt.Println(e.String(), e.CanSet()) // <main.X Value> true
	
	e.Set(reflect.ValueOf(X{1, 2, "banana"}))
	fmt.Println(a) // {1 2 banana}
}
```

# Changing fields
Individual fields can also be modified using Field methods:

Field returns a field using its index
FieldByIndex returns a nested field using a series of indexes
FieldByName returns a field using its name
FieldByNameFunc returns a field using  func(string) bool in the name
Let's define a structure to change the values of the fields, using both simple and complex types, with at least one unexported field:

```
更改字段
也可以使用字段方法修改各个字段：
字段返回使用其索引的字段
FieldByIndex返回使用一系列索引的嵌套字段
FieldByName返回使用其名称的字段
FieldByNameFunc返回在名称中使用func（string）bool的字段
让我们定义一个结构来更改字段的值，使用简单类型和复杂类型，其中至少有一个未排序的字段：

type A struct {
    B
    x int
    Y int
    Z int
}

type B struct {
    F string
    G string
}
```

Now that we have the structure, we can try to access the fields in different ways:

```
既然我们有了这个结构，我们可以尝试以不同的方式访问这些字段：


func main() {
	var a A
	v := reflect.ValueOf(&a)
 	func() {
		// trying to get fields from ptr panics
		defer func() {
			log.Println("panic:", recover()) // panic: reflect: call of reflect.Value.Field on ptr Value
		}()
		log.Printf("%s", v.Field(1).String())
	}()
	v = v.Elem()
	// changing fields by index
	for i := 0; i < 4; i++ {
		f := v.Field(i)
		if f.CanSet() && f.Type().Kind() == reflect.Int {
			f.SetInt(42)
		}
	}
	// changing nested fields by index
	v.FieldByIndex([]int{0, 1}).SetString("banana")

	// getting fields by name
	v.FieldByName("B").FieldByName("F").SetString("apple")

	log.Printf("%+v", a) // {B:{F:apple G:banana} x:0 Y:42 Z:42}
}

```

When working with reflect.Value and structure fields, what you get are other values, indistinguishable from the struct. When handling reflect.Type instead, you obtain a reflect.StructField structure, which is another type that carries all the information of the field with it.

使用reflect.value和structure字段时，您得到的是其他值，与结构不可区分。相反，在处理reflect.type时，您将获得一个reflect.structField结构，这是另一种类型，它包含字段的所有信息。


# Using tags

A structure field carries plenty of information, from the field name and index to its tag:

```
使用标签
结构字段包含大量信息，从字段名称和索引到其标记：

type StructField struct {
    Name string
    PkgPath string

    Type Type      // field type
    Tag StructTag  // field tag string
    Offset uintptr // offset within struct, in bytes
    Index []int    // index sequence for Type.FieldByIndex
    Anonymous bool // is an embedded field
}
```

A reflect.StructField value can be obtained using the reflect.Type methods:

Field
FieldByName
FieldByIndex

```
可以使用reflect.type方法获取reflect.structField值：
场
字段名
按索引字段


```

They are the same methods used by reflect.Value, but they return different types. The NumField method returns the total number of fields for the structure, allowing us to execute an iteration:

```
reflect.value使用的方法相同，但返回的类型不同。numField方法返回结构的字段总数，允许我们执行迭代：

type Person struct {
	Name    string `json:"name,omitempty" xml:"-"`
	Surname string `json:"surname,omitempty" xml:"-"`
}

func main() {
	v := reflect.ValueOf(Person{"Micheal", "Scott"})
	t := v.Type()
	fmt.Println("Type:", t) // Type: main.Person 
	for i := 0; i < t.NumField(); i++ {
		fmt.Printf("%v: %v\n", t.Field(i).Name, v.Field(i))
	}
	// Name: Micheal
	// Surname: Scott
}
```

Tags are really central to reflection because they can store extra information about a field and how other packages behave with it. To add a tag to a field, it needs to be inserted after the field name and type in a string, which should have a key:"value" structure. One field can have multiple tuples in its tag, and each pair is separated by a space. Let's look at a practical example:

```
标记对于反射非常重要，因为它们可以存储有关字段以及其他包如何使用字段的额外信息。要向字段添加标记，需要在字段名称后插入标记，并键入一个字符串，该字符串应具有键：“value”结构。一个字段的标记中可以有多个元组，并且每对由一个空格分隔。让我们来看一个实际的例子：

type A struct {
    Name    string `json:"name,omitempty" xml:"-"`
    Surname string `json:"surname,omitempty" xml:"-"`
}
```

This structure has two fields, both with tags, and each tag has two pairs. The Get method returns the value for a specific key:
这个结构有两个字段，都带有标记，每个标记有两对。get方法返回特定键的值：

```
type A struct {
	Name    string `json:"name,omitempty" xml:"-"`
	Surname string `json:"surname,omitempty" xml:"-"`
}

func main() {
	t := reflect.TypeOf(A{})
	fmt.Println(t) // main.A
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		fmt.Printf("%s JSON=%s  XML=%s\n", f.Name, f.Tag.Get("json"), f.Tag.Get("xml"))
	}
    // Name JSON=name,omitempty  XML=-
    // Surname JSON=surname,omitempty  XML=-
}

```



# Maps and slices
You can easily use reflection to read and manipulate maps and slices. Since they are such important tools for writing applications, let's see how to execute an operation using reflection.

地图和切片
您可以轻松地使用反射来读取和操作地图和切片。由于它们是编写应用程序的重要工具，我们来看看如何使用反射执行操作。


## Maps
A map type allows you to get the type of both value and key, using the Key and Elem methods:

```
地图
映射类型允许您使用key和elem方法同时获取value和key的类型：


func main() {
	maps := []interface{}{
		make(map[string]struct{}),
		make(map[int]rune),
		make(map[float64][]byte),
		make(map[int32]chan bool),
		make(map[[2]string]interface{}),
	}
	for _, m := range maps {
		t := reflect.TypeOf(m)
		fmt.Printf("%s - k:%-10s v:%-10s\n", m, t.Key(), t.Elem())
	}
}
/*
map[] - k:string     v:struct {} 
map[] - k:int        v:int32     
map[] - k:float64    v:[]uint8   
map[] - k:int32      v:chan bool 
map[] - k:[2]string  v:interface {}
*/
```


The values can be accessed in all the ways that a map can be accessed normally:

By getting a value using a key
By ranging over keys
By ranging over values
Let's see how it works in a practical example:

```
可以通过正常访问地图的所有方式访问这些值：
通过使用键获取值
通过搜索键
通过覆盖值
让我们看看它是如何工作的，在一个实际的例子中：

func main() {
    m := map[string]int64{
        "a": 10,
        "b": 20,
        "c": 100,
        "d": 42,
    }

    v := reflect.ValueOf(m)

    // access one field
    fmt.Println("a", v.MapIndex(reflect.ValueOf("a")))
    fmt.Println()

    // range keys
    for _, k := range v.MapKeys() {
        fmt.Println(k, v.MapIndex(k))
    }
    fmt.Println()

    // range keys and values
    i := v.MapRange()
    for i.Next() {
        fmt.Println(i.Key(), i.Value())
    }
}
```

Note that we don't need to pass a pointer to the map to make it addressable, because maps are already pointers.

Each method is pretty straightforward and depends on the type of access you need to the map. Setting values is also possible, and should always be possible because maps are passed by reference. The following snippet shows a practical example:

```
请注意，我们不需要向映射传递指针来使其可寻址，因为映射已经是指针。
每个方法都非常简单，取决于您需要访问地图的类型。设置值也是可能的，并且应该总是可能的，因为映射是通过引用传递的。下面的代码片段显示了一个实际示例：

func main() {
	m := map[string]int64{}
	v := reflect.ValueOf(m)

	// setting one field
	v.SetMapIndex(reflect.ValueOf("key"), reflect.ValueOf(int64(1000)))

	fmt.Println(m) // map[key:1000]
}
```

It is also possible to use this method to unset a variable, like we do when calling the delete function using the zero value of reflect.Value as a second argument:

```
也可以使用此方法取消设置变量，就像使用reflect.value的零值作为第二个参数调用delete函数时那样：

func main() {
	m := map[string]int64{"a": 10}
	fmt.Println(m, len(m)) // map[a:10] 1
	
	v := reflect.ValueOf(m)

	// deleting field
	v.SetMapIndex(reflect.ValueOf("a"), reflect.Value{})

	fmt.Println(m, len(m))  // map[] 0
}
```

The output will have one less field as it gets deleted because the length of the map decreases after SetMapIndex.
删除时，输出将少一个字段，因为在setmapindex之后，映射的长度将减小。


Slices
A slice allows you to get its size with the Len method and to access its elements using the Index method. Let's see that in action in the following code:

```
片
切片允许您使用len方法获取其大小，并使用index方法访问其元素。让我们在下面的代码中看到这一点：

func main() {
    m := []int{10, 20, 100}
    v := reflect.ValueOf(m)

    for i := 0; i < v.Len(); i++ {
        fmt.Println(i, v.Index(i))
    }
}
```

Since it is always possible to get the address of a slice element, it is also possible to use reflect.Value to change the content of the respective element in the slice:

```
由于总是可以获取slice元素的地址，因此也可以使用reflect.value更改slice中各个元素的内容：

func main() {
    m := []int64{10, 20, 100}
    v := reflect.ValueOf(m)

    for i := 0; i < v.Len(); i++ {
        v.Index(i).SetInt(v.Index(i).Interface().(int64) * 2)
    }
    fmt.Println(m)
}
```

It is also possible to append to a slice using the reflect package. If the value is obtained from the pointer to the slice, the result of this operation can also be used to replace the original slice:

```
也可以使用反射包附加到切片。如果从指向切片的指针获取值，则此操作的结果也可用于替换原始切片：

func main() {
    var s = []int{1, 2}
    fmt.Println(s)

    v := reflect.ValueOf(s)
    // same as append(s, 3)
    v2 := reflect.Append(v, reflect.ValueOf(3))
    // s can't and does not change
    fmt.Println(v.CanSet(), v, v2)
    
    // using the pointer allows change
    v = reflect.ValueOf(&s).Elem()
    v.Set(v2)
    fmt.Println(v.CanSet(), v, v2)
}
```

# Functions

Method and function handling with reflection allow you to gather information about the signature of a certain entry and also to invoke it. 
通过反射处理方法和函数，可以收集有关某个条目的签名的信息，还可以调用它。



# Analyzing a function
There are a few methods of reflect.Type in the package that will return information about a function. These methods are as follows:

NumIn: Returns the number of input arguments of the function
In: Returns the selected input argument
IsVariadic: Tells you if the last argument of the function is variadic
NumOut: Returns the number of output values returned by the function
Out: Returns the Type value of the select output
Note that all these methods will panic if the kind of reflect.Type is not Func. We can test these methods by defining a series of functions:

```
有几种reflect.type方法可以在包中返回有关函数的信息。这些方法如下：
numin：返回函数的输入参数数
In：返回所选输入参数
is variadic：告诉您函数的最后一个参数是否是variadic
numout：返回函数返回的输出值的数目。
out：返回选择输出的类型值
注意，如果reflect.type的类型不是func，那么所有这些方法都会恐慌。我们可以通过定义一系列函数来测试这些方法：

func Foo() {}func Bar(a int, b string) {}func Baz(a int, b string) (int, error) { return 0, nil }func Qux(a int, b ...string) (int, error) { return 0, nil }

```

# Invoking a function
While the type of the function shows information about it, in order to call a function, we need to use its value.

We will pass the function a list of argument values and get back the ones returned by the function call:

```
虽然函数的类型显示了关于它的信息，但是为了调用函数，我们需要使用它的值。
我们将向函数传递参数值列表，并返回函数调用返回的值：

func main() {   
     for _, f := range []interface{}{Foo, Bar, Baz, Qux} { 
       v, t := reflect.ValueOf(f), reflect.TypeOf(f)      
      name := runtime.FuncForPC(v.Pointer()).Name()      
      in := make([]reflect.Value, t.NumIn())     
       for i := range in {    
        switch a := t.In(i); a.Kind() {    
        case reflect.Int:          
      in[i] = reflect.ValueOf(42)         
   case reflect.String:            
    in[i] = reflect.ValueOf("42")   
         case reflect.Slice:          
      switch a.Elem().Kind() {        
        case reflect.Int:            
        in[i] = reflect.ValueOf(21)     
           case reflect.String:          
          in[i] = reflect.ValueOf("21")  
              }       
     }   
     }
 out := v.Call(in) ...
```

# Channels
Reflection allows us to create channels, send and receive data, and also to use select statements.
反射允许我们创建通道、发送和接收数据，以及使用select语句。

# Creating channels
A new channel can be created via the reflect.MakeChan function, which requires a reflect.Type interface value and a size:
创建频道
可以通过reflect.makechan函数创建新通道，该函数需要reflect.type接口值和大小：

```
func main() {
	reflect.ChanOf(reflect.BothDir, reflect.TypeOf(""))
	v := reflect.MakeChan(t, 0)
	fmt.Printf("%T\n", v.Interface())
}

```

# Sending, receiving, and closing
The reflect.Value type offers a few methods that have to be used exclusively with channels, Send and Recv for sending and receiving, and Close for closing channels. Let's take a look at a sample use case of these functions and methods:
```
发送、接收和关闭
reflect.value类型提供了一些方法，这些方法必须专门用于通道、发送和接收以及关闭通道。让我们来看看这些函数和方法的示例用例：

func main() {
	t := reflect.ChanOf(reflect.BothDir, reflect.TypeOf(""))
	v := reflect.MakeChan(t, 0)
	go func() {
		for i := 0; i < 10; i++ {
			v.Send(reflect.ValueOf(fmt.Sprintf("msg-%d", i)))
		}
		v.Close()
	}()
	for msg, ok := v.Recv(); ok; msg, ok = v.Recv() {
		fmt.Println(msg)
	}
}

```

# Select statement
A select statement can be executed with the reflect.Select function. Each case is represented by a data structure:

Select语句
可以使用reflect.select函数执行select语句。每种情况都由数据结构表示：

It contains the direction of the operation and both the channel and the value (for send operations). The direction can be either send, receive, or none (for default statements):
它包含操作的方向以及通道和值（对于发送操作）。方向可以是send、receive或none（对于默认语句）：  

func main() {    v := reflect.ValueOf(make(chan string, 1))    fmt.Println("sending", v.TrySend(reflect.ValueOf("message"))) // true 1 1    branches := []reflect.SelectCase{        {Dir: reflect.SelectRecv, Chan: v, Send: reflect.Value{}}, {Dir: reflect.SelectSend, Chan: v, Send: reflect.ValueOf("send")}, ...


# Reflecting on reflection
After talking how about how reflection works in all its aspects, we will now focus on its downside, when it is used in the standard library, and when to use it in packages.

反思
在讨论了反射在各个方面的工作方式之后，我们现在将重点讨论反射的缺点、反射在标准库中的使用时间以及反射在包中的使用时间。

 
# Performance cost
Reflection allows code to be flexible and handles unknown data types by analyzing their memory representation. This is not cost-free and, besides complexity, another aspect that reflection influences is performance.

We can create a couple of examples to demonstrate how some trivial operations are much slower using reflection. We can create a timeout and keep repeating these operations in goroutines. Both routines will terminate when the timeout expires, and we will compare the results:

性能成本
反射允许代码灵活，并通过分析内存表示形式来处理未知的数据类型。这不是免费的，除了复杂性，反射影响的另一个方面是性能。
我们可以创建两个示例来演示使用反射可以使一些琐碎的操作慢得多。我们可以创建一个超时，并在goroutine中不断重复这些操作。两个例程都将在超时到期时终止，我们将比较结果：

```go

func baseTest(fn1, fn2 func(int)) {    ctx, canc := context.WithTimeout(context.Background(), time.Second)    defer canc()    go func() {        for i := 0; ; i++ {            select {            case <-ctx.Done():                return            default:                fn1(i)            }        }    }()    go func() { for i := 0; ; i++ { ...
```


# Usage in the standard library
There are many different packages in the standard library that use the reflect package:

archive/tar
context
database/sql
encoding/asn1
encoding/binary
encoding/gob
encoding/json
encoding/xml
fmt
html/template
net/http
net/rpc
sort/slice
text/template
We can reason about their approach to reflection, taking as an example the encoding packages. Each of these packages offers interfaces for encoding and decoding, for instance, the encoding/json package. We have the following interfaces defined:



# Using reflection in a package
After seeing how reflection works and the kind of complications that it adds to code, we can think about using it in a package we are writing. One of the Go proverbs, from its creator Rob Pike, comes to the rescue:

Clear is better than clever. Reflection is never clear.
The power of reflection is huge, but it also comes at the expense of making code more complicated and implicit. It should be used only when it's extremely necessary, as in the template scenario, and should be avoided in any other case, or at least offer an interface to avoid it, as in the encoding packages.


在看到反射是如何工作的以及它给代码增加的复杂性之后，我们可以考虑在我们正在编写的包中使用它。其中一句俗语，出自其创造者罗伯·派克之手，来拯救：
清明胜于聪明。反省永远不清晰。
反射的力量是巨大的，但它也以使代码更加复杂和隐式为代价。它应该只在非常必要的时候使用，就像在模板场景中那样，在任何其他情况下都应该避免使用，或者至少提供一个接口来避免使用，就像在编码包中那样。



Questions
What's the memory representation of an interface in Go?
What happens when an interface type is cast to another one?
What are Value, Type , and Kind in reflection?
What does it mean if a value is addressable?
Why are structure field tags important in Go?
What's the general trade-off of reflection?
Could you describe a good approach to using reflection?