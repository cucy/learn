# Chapter 1

- 应用程序和系统编程区别

> 应用程序重点是为最终用户解决问题, 系统编程是为其他应用软件提供接口调用

- 什么是API,为何API非常重要
 
> API是软件公开调用的接口,用于控制其对资源的访问,它描述了其他应用程序应如何与其他软件进行通信

- 环0到环3是如何工作的

> 0环是防止故障和提高系统安全性,他们具有不断增长限制分层级别中安排安全性,并允许通过使用特定网关对齐进行中间访问


# Chapter 2

- 现在操作系统使用哪个文件系统

> 不同操作系统用的文件系统不相同, windows主要是ntfs,macos使用的是APF,linux主要是ext4, xfs

- 什么是inode,unix中inode 0是什么?

> inode是表示文件的文件系统数据结构. 它存储有关文件的信息, 不包括名称和数据.inode 0 是为文件夹保留的

- pid ,ppid有何区别

> pid是现有进程的唯一标识符,而ppid是父进程标识符. 当现有进程创建另个一个进程时, 新进程的ppid等于现有进程PID


- 怎样终止后台运行进程

# Chapter 3

- 导出符号和未导出符号有什么区别？

> 导出的符号可以被其他包使用，而未导出的符号则不能。第一组具有以大写字母开头的标识符，而第二组没有。
 
 
 - 为什么自定义类型很重要
 
> 自定义类型允许用户自定义方法或接口, 或可继承其他类型的数据结构,方法


- 简短声明的主要限制是什么?

> 短式声明不允许由值推断变量的类型, 值类型转换是的能够克服该限制

- 什么是变量的范围,它影响的范围是哪

# Chapter 4

- 绝对路径和相对路径区别

> linux绝对路径以`/`开头, 相对路径不是. 想要从相对路径得到绝对路径,需要连接/目录

- 如何获取或更改当前工作目录

> os.Getwd获取到当前目录, os.Chdir 改变当前工作目录,可以是相对目录,或者绝对目录

- 使用ioutil.ReadAll 优缺点

> ioutil.ReadAll将整个文件内容放在一个字符切片中, 因此文件大小会影响内存使用量

# Chapter 5

- 什么是流

> 流是一种抽象,表示传入和传出数据的通用流

- 什么是接口抽象输入流

> io.Reader接口是用于输入流的抽象

- 什么是接口抽象输出流
 
> io.Writer接口是输出流的抽象

- 何时使用byte reader ,怎样使用string reader?

> 当原始数据是一个[]byte时,应该使用byte reader, 而string reader应和字符串一起使用,从一种数据类型转换成另一种数据类型会产生副本,且不方便

- string builder 和 byte buffer 区别

> byte buffer  可以来回的覆盖读写,不需要频繁的申请内存


# Chapter 6

- pseudo-terminal(伪终端)和 终端区别

> 终端是一种行为类似电打字的应用程序,通过显示2x2字符矩阵; 伪终端是在终端下运行并通过交互模拟其行为的应用程序

- 伪终端是如何实现,原理

> 伪终端程序应能接收来自用户的输入,根据接收的指令执行动作, 并将结果显示给用户

- 我们如何使用go来实现伪终端

> 为了管理用户输入,我们使用buffered scanner读取一行一行标准输入, 每个命令都用相同的接口实现 


# Chapter 7

- go怎样获取自己进程的信息?

> 通过pid获取到唯一标识符, ppid获取到父进程,uid,gid等获取到用户权限信息,以及工作目录

- 怎样创建一个子进程

>  exec.Cmd 定义一个子进程的数据结构元信息等,  Run, Start, Output, and CombinedOutput方法进行调用

- 如何保证父进程退出后子进程依然存活

> 默认情况下父进程退出后,子进程也会退出; 可以通过改变进程组和会话id

> 怎样访问子进程,调用等

# Chapter 8

- 什么是退出状态码,如何使用它

> 退出码是从进程传递给父进程的整数值,以及在进程结束时发出信号;它代表流程的结果. 0表示程序正常执行完成任务. 父进程可以通过退出码决定下一步该怎样操作

- 程序发出panics错误时会发生什么, 退出码是什么?

> 当程序发出panic 且没有使用recovere函数进行处理, 它会使整个程序退出,且退出码为2


- 接收所有信号时go程序默认的行为是什么?

> 退出

- 如何拦截捕获信号
 
 
 # Chapter 8

- 使用通信模型有什么好处

> 它可以抽象使用模型处理的数据类型, 使用不同的端点之间通信变得容易


- tcp , udp 区别

- 谁在发送请求时关闭请求正文

-   Closing the request when making an HTTP call is the responsibility of the application

> 在进行HTTP调用时关闭请求是应用程序的责任


# Chapter 10

- 文本和二进制编码间的权衡

> 文本编码使人易于阅读,调式编写; 二进制使人难理解,读写调式,但是优点是占用空间小

- 在编码时，默认情况下Go如何使用数据结构

> 反射


# Chapter 11

- 什么是线程, 谁负责?

> 线程由特定核心或者CPU分配的进程一部分. 它携带应用程序状态信息; 类似进程一样, 它由操作系统调度程序管理


- goroutine和线程区别

> 比线程小, 数据结构相对简单, 不受操作系统调度管理. 而是由go runtime进行调度管理

- 何时在启动goroutine时评估参数

# Chapter 12

- 什么是 race condition

> 竞争条件是应用程序同一时间在同一资源上执行两个操作,且资源的性质仅允许一次操作

- 同时对map进行读写操作会发生什么?

> concurrent map writes.


- Mutex 和 之间有什么区别RWMutex

>  常规互斥锁允许锁定和解锁资源， 并且每个操作具有相同的优先级。读/写互斥锁有两种类型的锁，每种操作一个（读/写）。读锁定允许一次执行多个操作，而它是独占的。写......


# Chapter 13

- Context 包作用

> 它用于同步应用程序的各个部分之间的操作并携带值。

- What's the difference between cancellation, deadline, and timeout?

> 上下文取消有三种不同类型的到期是应用程序对取消函数的显式调用，截止时间是上下文超过指定时间，超时是上下文在特定持续时间内存活的时间


- 使用上下文传递值时的最佳做法是什么？传递上下文的值应该与当前范围或请求相关。它们不应该被用作

# Chapter 14

- 什么是生成器,其作用

>  生成器是一个返回一系列值的工具 - 它在每次调用时返回系列中的下一个值。它负责按需生成序列中的值。在Go中，这可以通过使用通道来接收由创建它们的goroutine发送的值来完成。


- 你会如何描述一条管道？

> 管道是一种应用程序流，它将执行分成不同的阶段。这些阶段通过使用某种通信手段（例如网络）或运行时内部（例如信道）彼此通信。


- What type of stage gets a channel and returns one? An intermediate stage will receive from a receive-only channel ...

> 什么类型的舞台获得一个频道并返回一个？中间阶段将从仅接收频道收到......

# Chapter 15

- What's the memory representation of an interface in Go ? Go中接口的内存表示是什么

> Go中的接口由两个值表示 - 第一个是接口具体类型，第二个是这种类型的值。

- 当接口类型转换为另一个接口类型时会发生什么？

> 由于接口值需要是具体值，并且不能是另一个接口，因此创建具有不同类型和相同具体值的新接口

- What are Value, Type, and Kind in reflection?

什么是 Value， Type和 Kind 反射？ 甲Value，顾名思义，表示可变的内容; a  Type表示变量的Go类型; 并且Kind是a的内存表示，Type 仅指内置类型。

